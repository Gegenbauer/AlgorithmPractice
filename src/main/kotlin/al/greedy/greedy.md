## 贪心算法

> 1) 最自然智慧的算法
> 2) 用一种最功利的标准，总是做出在当前看来是最好的选择
> 3) 难点在于证明局部最功利的标准可以得到全局最优解
> 4) 对于贪心算法的学习主要以增加阅历和经验为主，没有套路
>
> 笔试出现概率较高，面试几乎不会出现
>
> 1. 代码通常非常简单，最关键的是贪心策略的选取
>
> 2. 起不到考核 coding 的作用
> 3. 区分度不够，要么选取了正确的策略结果正确，要么选取了错误的策略，结果错误
>
> 不需要去证明，笔试通过用例去测试，面试可以通过对数器证明

### 贪心易错示例

#### 矩阵中收集1的问题

题目描述

>从左上出发，到右下，再从右下返回到左上，求能收集到的最多的 1
>
>要求：
>
>1. 出发的时候只能往下或者往右，返回的时候只能往上或者往左
>
>2. 以及收集过的 1，下次不能再收集

反例

>贪心策略：出发的时候搜集最多的 1，返回的时候也收集最多的 1
>
>反例：
>
>```txt
>1 1 1 1 0 0 0
>0 0 0 1 0 0 1
>1 0 0 1 0 0 0
>0 0 0 1 1 1 1
>```
>
>这个反例下，如果按照上面的贪心策略，则会导致无法收集到全部的 1，实际可以收集到
>
>所以得到的不是全局最优解

### 利用贪心算法求解的题

#### 最小字典序的字符串数组拼接结果

题目描述

>给定一个由字符串组成的数组 strs，
>
>必须把所有的字符串拼接起来，
>
>返回所有可能的拼接结果中，字典序最小的结果
>
>>字典序
>>
>>长度相同时，依次比较字符大小
>>
>>长度不同时，较短的字符串后面补全认为是最小的 ascii 字符

贪心策略

>贪心策略一
>
>> 将字符串数组按照字典序排序，每次都选择剩余字符串中字典序最小的字符串
>
>反例
>
>`["b", "ba"]`
>
>`"b" < "ba"`，所以拼接出来的字符串为 `"bba"`
>
>但实际上最小的字符串为`"bab"` 
>
>
>
>贪心策略二
>
>> 将字符串数组按照 `如果 "ab" < "ba", 则 "ab" 更小`
>
>证明：
>
>> 证明排序策略具有传递性（a < b && b < c => a < c），即证明这种排序策略下得到的结果是唯一的
>>
>> > 石头剪刀布不具有传递性，大小顺序具有循环性
>>
>> 1) "ab" < "ba"
>> 2) "bc" < "cb"
>> 3) "ac" < "ca"
>>
>> 如果 1，2 成立，能证明 3，则表明
>
>> 证明排序完的字符串数组，任意两个字符串一旦交换顺序，字典序只会变大

#### 会议室的安排

题目描述

>```
>会议室能安排的会议的最大数量
>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。
>给你每一个项目开始的时间和结束的时间
>你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。
>返回最多的宣讲场次。
>```

贪心策略

> 贪心策略一
>
> > 优先安排开始时间早的会议
>
> 反例
>
> > [1, 10], [2, 3], [3, 4]
> >
> > 按照贪心策略一 只能安排一个会议 [1, 10]
>
> 
>
> 贪心策略二
>
> > 优先选择会议持续时间短的会议
>
> 反例
>
> >[1, 27], [26, 31], [29, 300]
> >
> >按照贪心策略一 只能安排一个会议 [26, 31]
>
>
> 贪心策略三
>
> > 优先选择结束时间最早的会议
>
> 