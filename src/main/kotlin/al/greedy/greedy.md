## 贪心算法

> 1) 最自然智慧的算法
> 2) 用一种最功利的标准，总是做出在当前看来是最好的选择
> 3) 难点在于证明局部最功利的标准可以得到全局最优解
> 4) 对于贪心算法的学习主要以增加阅历和经验为主，没有套路
>
> 笔试出现概率较高，面试几乎不会出现
>
> 1. 代码通常非常简单，最关键的是贪心策略的选取
>
> 2. 起不到考核 coding 的作用
> 3. 区分度不够，要么选取了正确的策略结果正确，要么选取了错误的策略，结果错误

### 贪心易错示例

#### 矩阵中收集1的问题

题目描述

>从左上出发，到右下，再从右下返回到左上，求能收集到的最多的 1
>
>要求：
>
>1. 出发的时候只能往下或者往右，返回的时候只能往上或者往左
>
>2. 以及收集过的 1，下次不能再收集

反例

>贪心策略：出发的时候搜集最多的 1，返回的时候也收集最多的 1
>
>反例：
>
>```txt
>1 1 1 1 0 0 0
>0 0 0 1 0 0 1
>1 0 0 1 0 0 0
>0 0 0 1 1 1 1
>```
>
>这个反例下，如果按照上面的贪心策略，则会导致无法收集到全部的 1，实际可以收集到
>
>所以得到的不是全局最优解

### 利用贪心算法求解的题

#### 最小字典序的字符串数组拼接结果

题目描述

>给定一个由字符串组成的数组 strs，
>
>必须把所有的字符串拼接起来，
>
>返回所有可能的拼接结果中，字典序最小的结果
>
>>字典序
>>
>>长度相同时，依次比较字符大小
>>
>>长度不同时，较短的字符串后面补全认为是最小的 ascii 字符

>贪心策略一
>
>> 将字符串数组按照字典序排序，每次都选择剩余字符串中字典序最小的字符串
>
>反例
>
>`["b", "ba"]`
>
>`"b" < "ba"`，所以拼接出来的字符串为 `"bba"`
>
>但实际上最小的字符串为`"bab"` 

> 贪心策略二
>
> > 将字符串数组按照 `如果 "ab" < "ba", 则 "ab" 更小`
>
> 证明：
>
> > 证明排序策略具有传递性（a < b && b < c => a < c），即证明这种排序策略下得到的结果是唯一的
> >
> > > 石头剪刀布不具有传递性，大小顺序具有循环性
> >
> > 1) "ab" < "ba"
> > 2) "bc" < "cb"
> > 3) "ac" < "ca"
> >
> > 如果 1，2 成立，能证明 3，则表明
>
> > 证明排序完的字符串数组，任意两个字符串一旦交换顺序，字典序只会变大