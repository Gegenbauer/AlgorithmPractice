## 排序的稳定性

稳定的排序方法，指原来在数组中相等的两个数，排序后他们的前后次序不能发生改变

它是针对非基本类型的排序。

> 如果让一批商品按照价格升序，再按照好评度降序，则可以让相同好评的商品，价格从低到高排序。
>
> 有些算法通过调整具体实现，可以做到保证排序稳定性，有些则不能

## 基于比较的排序

指通过元素间的比较来进行排序，对数据无要求，复杂度最多为 `O(N * logN)`

### 选择排序

#### 流程

> 每次遍历选出`最小`的元素，将其与当前遍历序列第一个位置交换

#### 时间复杂度

> 最好最坏都是`O(N ^ 2)`

#### 额外空间复杂度

#### 稳定性

> **不稳定**
>
> 例如：3, 2, 3, 3, 1
> 第一次遍历会将第一个 3 移动到末尾的位置，导致和其他 3 的相对顺序发生改变

`O(1)`

### 冒泡排序

#### 流程

>每次遍历，比较相邻两个数，确保两个数的大小顺序，直到将当前序列的最大数移动到末尾的位置

#### 时间复杂度

`O(N ^ 2)`

> 最好情况是 `O(N)`：已经排好序的数组，如果第一次冒泡没有发生交换，则可以终止排序

#### 额外空间复杂度

`O(1)`

#### 稳定性

>**稳定**
>
>如果相等元素不交换，冒泡排序不会导致相等元素的相对顺序发生变化

### 插入排序

#### 流程

> 每次认为前面的序列已经排好序，然后将下一个元素向前遍历，如果顺序不对，则交换位置

#### 时间复杂度

> `O(N ^ 2)`
>
> 最好情况是 `O(N)`：已经排好序的数组，每次遍历都只需要比较一次

#### 额外空间复杂度

> `O(1)`

#### 稳定性

> **稳定**
>
> 如果相等元素不交换，则是稳定的

### 归并排序

#### 流程

>每次将当前序列根据中点位置划分为两部分，直到两个部分都只有一个元素
>
>然后依次往上合并
>
>> 核心操作是两个排好序的子数组合并：`merge(arr: IntArray, l: Int, mid: Int, r: Int)`
>>
>> 两个指针分别指向两个需要合并的子序列，保证每次先取最小的元素

#### 时间复杂度

>最好最坏都是 `O(N * logN)`

#### 额外空间复杂度

主要为合并时用到的辅助数组

> `O(N)`

#### 稳定性

> 可以实现稳定的归并排序算法
>
> 要求合并时，相等的元素应该取左边的值

### 快速排序

#### 流程

>每次取数组内一个值作为基准，将基准值放置元素末尾
>
>然后遍历每个元素，并基于选取的基准元素，对数组进行划分，最终使得小于基准值的元素在左边，等于基准值的元素在中间，大于基准值的元素在右边
>
>最后将元素末尾的值跟大于基准值的第一个元素交换
>
>> 快排的核心操作是基于基准值划分数组：`partition(arr: IntArray, l: Int, r: Int): IntArray`
>>
>> 取最后一个元素为基准
>>
>> 指针`smallBound`指向小于区域的最后一个元素，指针`largeBound`指向大于区域的第一个元素
>>
>> 然后遍历数组
>>
>> 如果元素小于基准元素，则将其与小于区域的下一个元素交换，小于区域指针指向下一个位置
>>
>> 如果元素大于基准元素，则将其与大于区域的前一个元素交换，大于区域指针指向前一个位置
>>
>> 如果元素等于基准元素，continue

#### 时间复杂度

> 最差情况是 `O(N^2)`：数组刚好完全逆序，且无重复元素，此时每次 partition 只能排好一个元素
>
> 最好情况是`O(N)`：数组元素全部相等，则只需要一次 partition 就可以排好
>
> 如果每次都随机选取基准值，则可以避免最差情况，复杂度可以来到`O(N * logN)`

#### 额外空间复杂度

>`O(logN)`

#### 稳定性

> 不稳定
>
> 对于数组：4, 4, 4, 2, 2, 1, 1
> partition 过程中，如果基准值是 2，则 4 的顺序会被反转

### 堆排序

#### 流程

> 1. 将数组建成最大堆
> 1. 将顶部元素与最后一个元素交换，将堆的规模减 1
>
> 循环步骤 2，即可排好序

#### 时间复杂度

> 最好最坏都是`O(N * logN)`

#### 额外空间复杂度

`O(1)`

#### 稳定性

>不稳定，调整大根堆的过程就是不稳定的
>
>例如：4, 4, 4, 4, 6

## 不基于比较的排序

指不通过元素间比较来排序，要求数据满足一定条件，复杂度可以到 `O(N)`

### 桶排序
也可以称为`基于容器的排序`
#### 计数排序

#### 数据条件

> 要求数据取值范围较小

#### 流程

> 创建一个计数数组，计数数组的索引对应数组某个元素的值，计数数组的值代表该值出现的次数
> 依次遍历数组，将每个元素出现次数记录在计数数组中
>
> 遍历计数数组，依次覆盖原数组的数

#### 时间复杂度

> `O(N)`

#### 额外空间复杂度

> `O(K)`
>
> 计数数组占用的空间

#### 稳定性

> 不稳定
>
> 计数后，重新生成的数组不保留原来数组相等元素的信息

#### 基数排序

#### 数据条件

> 要求数据的位数较低，且一般来说数据不能为负

#### 流程

>创建一个临时数组 help，用来存放基于某位的排序结果
>
>创建一个临时数组 bitCounts，用来记录某位每个数出现的次数
>
>1. 从低位开始依次往上
>
>2. 顺序遍历数组，生成 bitCounts
>
>3. 将 bitCounts 数组处理成前缀和数组
>
>4. 倒序遍历数组，根据前缀和数组，可以得到该元素应该在的位置（倒序目的是为了保证排序稳定性），将其放入 help
>
>5. 将 help 拷贝到原数组
>
>遍历下一位，重复 2- 5


## 汇总

| 排序方法     | 时间复杂度     | 额外空间复杂度                       | 排序稳定性 |
| ------------ | -------------- | ------------------------------------ | ---------- |
| 选择排序     | ` O(N ^ 2)`    | `o(1)`                               | 无         |
| 冒泡排序     | ` O(N ^ 2)`    | `o(1)`                               | 有         |
| 插入排序     | ` O(N ^ 2)`    | `o(1)`                               | 有         |
| 归并排序     | ` O(N * logN)` | `O(N)`                               | 有         |
| 随机快速排序 | ` O(N * logN)` | `o(logN)`                            | 无         |
| 堆排序       | ` O(N * logN)` | `o(1)`                               | 无         |
| 计数排序     | `O(N)`         | `O(K)` <br />`K`等于数组 `max-min+1` | 无         |
| 基数排序     | `O(N)`         | `O(N)`                               | 有         |

#### 结论

>如果追求速度，选随机快排。考虑常数时间，基于比较的排序中，快速排序是最快的。
>
>如果追求算法稳定性，则选择归并排序。
>
>如果追求较少额外空间复杂度，则选择堆排序。

#### 常见坑

1) 归并排序的额外空间复杂度可以变为`O(1)`，`归并排序 内部缓存法`，但是将变得不稳定，不如堆排序
2) `原地归并排序`并不好，号称额外空间复杂度为`O(1)`，而且稳定，但会让时间复杂度变成`O(N ^ 2)`，不如堆排序
3) 快速排序稳定性改进，`01 stable sort`，但是会对样本要求要求更多，不如使用对数据有要求的桶排序
4) 对于一个数组，进行整理，将奇数放左边，偶数放右边，且不改变奇数间的顺序和偶数间的顺序，时间复杂度为 `O(N)`，额外空间复杂度为`O(1)`。无法实现

#### 工程上对排序的改进

1. 数据量较小可以选插入排序，常数项小
2. 基础类型，快排（双轴快排算法）
3. 对象类型，可以选归并排序
