package al.disjointset

/**
 * leetcode-924 尽量减少恶意软件的传播
 * 给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j。
 * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
 * 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 * 如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
 * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。
 *
 * 示例 1：
 * 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * 输出：0
 *
 * 示例 2：
 * 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * 输出：0
 *
 * 示例 3：
 * 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * 输出：1
 *
 * 提示：
 * n == graph.length
 * n == graph[i].length
 * 2 <= n <= 300
 * graph[i][j] == 0 或 1.
 * graph[i][j] == graph[j][i]
 * graph[i][i] == 1
 * 1 <= initial.length <= n
 * 0 <= initial[i] <= n - 1
 * initial 中所有整数均不重复
 *
 * 每次删除感染节点时，原来图中节点不会被移除
 */
class MinMalwareSpread {
    fun minMalwareSpread(graph: Array<IntArray>, initial: IntArray): Int {
        val unionSet = UnionSet(graph.size)
        for (i in graph.indices) {
            for (j in graph[0].indices) {
                if (graph[i][j] == 1) {
                    unionSet.union(i, j)
                }
            }
        }

        initial.forEach { unionSet.infect(it) }
        val infectedNodes = initial.sorted()
        var target = -1
        for (infectedNode in infectedNodes) {
            val root = unionSet.getRoot(infectedNode)
            val infectedCount = unionSet.getInfectedCount(root)
            if (infectedCount == 0 || infectedCount > 1) continue
            if (target == -1) {
                target = infectedNode
            } else if (unionSet.getSize(unionSet.getRoot(target)) < unionSet.getSize(root)) {
                target = infectedNode
            }
        }
        return target.takeIf { it != -1 } ?: infectedNodes.first()
    }

    /**
     * leetcode-928 尽量减少恶意软件的传播 II
     * 每次删除感染节点时，原来图中节点也会被移除
     */
    fun minMalwareSpread2(graph: Array<IntArray>, initial: IntArray): Int {
        val infectedNodes = initial.sorted()
        var target = infectedNodes.first()
        var infectedCount = Int.MAX_VALUE
        for ((nodeIndex, node) in infectedNodes.withIndex()) {
            val unionSet = UnionSet(graph.size)
            for (i in graph.indices) {
                for (j in graph[0].indices) {
                    if (graph[i][j] == 1 && i != node && j != node) {
                        unionSet.union(i, j)
                    }
                }
            }
            val resetInfectedNodes = infectedNodes.filterIndexed { index, i -> index != nodeIndex }
            resetInfectedNodes.forEach { unionSet.infect(it) }

            var restInfectedCount = 0
            for (set in unionSet.getInfectedSets()) {
                restInfectedCount += unionSet.getSize(set)
            }
            if (restInfectedCount < infectedCount) {
                target = node
                infectedCount = restInfectedCount
            }
        }

        return target
    }

    private class UnionSet(nodeSize: Int) {

        private val parents = IntArray(nodeSize)
        private val sizes = IntArray(nodeSize)
        private val help = IntArray(nodeSize)

        // 集合代表节点 : 集合中受感染节点个数
        private val infectedCount = IntArray(nodeSize)

        init {
            for (i in 0 until nodeSize) {
                parents[i] = i
                sizes[i] = 1
            }
        }

        fun getRoot(node: Int): Int {
            var helpIndex = 0
            var cur = node
            while (parents[cur] != cur) {
                help[helpIndex++] = cur
                cur = parents[cur]
            }
            val root = cur
            while (helpIndex > 0) {
                parents[help[--helpIndex]] = root
            }
            return root
        }

        fun infect(node: Int) {
            val root = getRoot(node)
            infectedCount[root]++
        }

        fun union(node1: Int, node2: Int) {
            val rootA = getRoot(node1)
            val rootB = getRoot(node2)
            if (rootA == rootB) return

            val sizeA = sizes[rootA]
            val sizeB = sizes[rootB]
            if (sizeA > sizeB) {
                parents[rootB] = rootA
                sizes[rootA] = sizeA + sizeB
                sizes[rootB] = 0
            } else {
                parents[rootA] = rootB
                sizes[rootB] = sizeA + sizeB
                sizes[rootA] = 0
            }
        }

        fun getInfectedSets(): List<Int> {
            val result = arrayListOf<Int>()
            for ((index, count) in infectedCount.withIndex()) {
                if (count > 0) {
                    result.add(index)
                }
            }
            return result
        }

        fun getInfectedCount(root: Int): Int {
            return infectedCount[root]
        }

        fun getSize(root: Int): Int {
            return sizes[root]
        }
    }
}